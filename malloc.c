#include <stdio.h>
#include <stdlib.h>

int main() {
    // 创建一个静态的数组
    int arr[100] = { 100 };
    // 未定义行为，free 只能释放堆上开辟的空间
    // malloc 和 free 一定是搭配使用  
    free(arr);

    // 创建一个动态的数组,运行时决定数组的大小
    // 内存泄漏：堆上申请的内存生命周期比较长，如果用完之后不手动释放的话，
    // 后续再申请堆上的内存就可能会申请失败(内存不够了).把不需要使用的内存及时释放掉.
    // 如果没有及时的释放掉，此时产生的现象，就叫内存泄漏
    // 如果malloc申请的内存，本来还需要使用，但是提前被释放掉了
    // 此时再去使用这个内存，就会出现未定义行为
    


    // C++ 之后的大部分编程语言都引入了垃圾回收机制(GC)，能够有效地简化程序猿堆内存的操心程度
    // 但是GC机制最大的问题是引入了很大的额外的开销.以及最致命的 STW 问题
    // stop the world (Java 在这个方面其实已经优化的非常好了)
    // C++ 的核心价值观
    // 1. 高效(性能榨汁机)
    // 2. 和C兼容
    
    // 智能指针
     
    int n= 100;
    // 假设第一次 malloc 返回的结果 0x100
    // 假设第二次 malloc 返回的结果 0x200
    int *ptr = (int *)malloc(sizeof(int) * 100);
    ptr = (int *)malloc(sizeof(int) * 100);
    for (int i = 0; i < 100; ++i) {
        ptr[i] = i;
    }
    free(ptr);
    // 对一个已近释放的内存，在释放一次，这也是未定义行为
    // 因为不能确定在第一次释放之后，以及在第二次释放之前
    // 在这个执行过程中这段内存有没有被别人申请走
    // 一个程序再跑的时候有可能不是只有一条执行流再跑
    
    ptr = NULL;
    // 对空指针进行 free，没事~~ 
    free(ptr);


    // 针对 malloc 申请出的内存进行释放的时候，如果 free 的地址不是 malloc 返回的地址
    // 结果就是未定义行为
    // int *p = (int *)malloc(100);
    // p++;
    // free(p);
    return 0;
}
